> 测试代码均在C++20版本，64位Win11系统下编译运行

# C++ vs Go
## 一、实际使用中的区别

     区别                          C++                                 Go
    大小写                       大小写敏感                          大小写极度敏感
     语句                      语句以分号结尾                        语句结尾可加分号
     内存                    手动控制内存使用释放                    系统控制内存使用释放
    类型定义                  类型在前，变量名在后                    变量名在前，类型在后
     IO                            #1                                



> #1：源文件入口引入C的库（#include <iostream>，其中`#include`是预处理编译指令），源文件编译时，预处理器处理`#include <iostream>`，将`#include <iostream>`取代为`iostream文件`的内容，原始文件没有被修改，而是将`源文件`和`iostream文件内容组合成一个复合文件`，编译的下一阶段将使用该复合文件;
>
> 使用编译指令（`using namespace std;`，使用`iostream`而不是`iostream.h`时需声明，表示可以使用std名称空间中定义的名称，而不必使用`std::`前缀，如可以直接使用`cout`而不是`std::cout`）；
> 名称空间：![name_space.png](..%2Fimage%2Fname_space.png)
> 名称空间更好的使用方式：![name_space_better_use.png](..%2Fimage%2Fname_space_better_use.png)
>
> C++使用`cin`、`cout`进行输入输出（使用`cin`、`cout`进行输入输出的程序必须包含`文件iostream`）；

> 补充知识：
> 
> 翻译器也是一种预处理器（处理源文件），即它处理名称以#开头的编译指令；不必执行任何特殊的操作来调用该预处理器，它会在编译程序时自动执行；

## 二、C++头文件

> 库文件中包含了函数的编译代码（即函数定义），而头文件中则包含函数了原型（即函数声明）；

### 2.1 头文件：![head_file.png](..%2Fimage%2Fhead_file.png)

### 2.2 头文件约定：![head_file_promise.png](..%2Fimage%2Fhead_file_promise.png)

## 三、处理数据

### 3.1 简单变量

#### 3.1.1 bit与byte

bit（位、比特）：
* 计算机内存的基本单元；
* 8位的内存块可以设置出256中不同的组合，因此每一位都可以有两种设置；
  * 8位的总组合数为：`2 * 2 * 2 * 2 * 2 * 2 * 2 * 2`，即256；
  * 因此8位单元可以表示`0-255`（符号类型）或者`-128到127`（无符号类型）；
  * 同理16位单元可以表示`0-65535`（符号类型）或者`-32768到32767`（无符号类型）；

byte（字节）：
* 字节（byte）通常指的是8位的内存单元；
  * 从这个意义讲，字节指的就是描述计算机内存量的度量单位；
  * 1KB = 1024Byte；
  * 1MB = 1024KB；
  * 1GB = 1024MB；
  * 1TB = 1024GB；
> C++对字节的定义与此不同，C++字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说，可能取值的数目必须等于或超过字符数目。

width（宽度）：
* 用于描述存储整数时使用的内存量；
  * 使用的内存越多，则越宽；
  * C++的基本整型（按宽度递增的顺序排序）分别是char（最常用来表示字节，而不是数字）、short、int、long、long long（C++11新增）；
  * 每种基本整型都有符号版本和无符号版本；

#### 3.1.2 整型变量

* short
    * 4 byte
* int
  * 4 byte
* long
  * 4 byte
* long long
  * 8 byte

头文件climits定义了符号常量来表示类型的限制，下图为对该文件中定义的符号常量进行了总结：
![symbolic_constants_01.png](..%2Fimage%2Fsymbolic_constants_01.png)
![symbolic_constants_02.png](..%2Fimage%2Fsymbolic_constants_02.png)

#### 3.1.3 无符号类型

前面提到的4种整型都有一种不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值；  
例如，如果short表示的范围为-32768到+32767，则无符号版本的表示范围为0-65535；  
使用关键字`unsigned`来修改声明，例如：`unsigned short change`；

整型溢出:

> 观看../../code/integerOverflow.cpp代码；
* 当有符号整型处于最大值时，再进行+1操作时，值会变为范围的下限；
  * 如short类型的值会从32767变为-32768；
* 当有符号整型处于最小值时，在进行-1操作时，值会变为范围的上限；
  * 如short类型的值会从-32768变为32767；
* 当无符号整型处于最大值时，再进行+1操作时，值会变为范围的下限；
  * 如unsigned short类型的值会从65535变为0；
* 当无符号整型处于最小值时，再进行-1操作时，值会变为范围的上限；
  * 如unsigned short类型的值会从0变为65535；

![integerOverflow.png](..%2Fimage%2FintegerOverflow.png)

#### 3.1.4 整型类型选择

选择整型类型时，还要考虑到进行移植的时候会不会出现溢出的情况：
  * 如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long；
  * 即使系统上int为32位，也应这样做，这样将程序移植到16位系统时，就不会突然无法正常工作；
  * 如果要存储的值超过20亿，可使用long long；

同时，还要考虑低位系统移植到高位系统时，占用内存量会加倍：
  * 如假设要将程序从int为16位的系统移植到32位的系统，则用于存储int数组的内存量则加倍；
  * 但short数组不受影响；

#### 3.1.5 整型字面值

十进制：
  * 第一位`1~9`；

八进制：
  * 第一位为`0`，第二位为`1~7`；

十六进制：
  * 如果前两位为`0x`或`0X`；
  * 字符a~f和A~F表示了十六进制位，对应10~15，如0xF为15，,0xA5为165（10个16加5个1）；













































    