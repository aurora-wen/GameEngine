> 测试代码均在C++20版本，64位Win11系统下编译运行

# C++ vs Go
## 一、实际使用中的区别

     区别                          C++                                 Go
    大小写                       大小写敏感                          大小写极度敏感
     语句                      语句以分号结尾                        语句结尾可加分号
     内存                    手动控制内存使用释放                    系统控制内存使用释放
    类型定义                  类型在前，变量名在后                    变量名在前，类型在后
     IO                            #1                                



> #1：源文件入口引入C的库（#include <iostream>，其中`#include`是预处理编译指令），源文件编译时，预处理器处理`#include <iostream>`，将`#include <iostream>`取代为`iostream文件`的内容，原始文件没有被修改，而是将`源文件`和`iostream文件内容组合成一个复合文件`，编译的下一阶段将使用该复合文件;
>
> 使用编译指令（`using namespace std;`，使用`iostream`而不是`iostream.h`时需声明，表示可以使用std名称空间中定义的名称，而不必使用`std::`前缀，如可以直接使用`cout`而不是`std::cout`）；
> 名称空间：![name_space.png](..%2Fimage%2Fname_space.png)
> 名称空间更好的使用方式：![name_space_better_use.png](..%2Fimage%2Fname_space_better_use.png)
>
> C++使用`cin`、`cout`进行输入输出（使用`cin`、`cout`进行输入输出的程序必须包含`文件iostream`）；

> 补充知识：
> 
> 翻译器也是一种预处理器（处理源文件），即它处理名称以#开头的编译指令；不必执行任何特殊的操作来调用该预处理器，它会在编译程序时自动执行；

## 二、C++头文件

> 库文件中包含了函数的编译代码（即函数定义），而头文件中则包含函数了原型（即函数声明）；

### 2.1 头文件：![head_file.png](..%2Fimage%2Fhead_file.png)

### 2.2 头文件约定：![head_file_promise.png](..%2Fimage%2Fhead_file_promise.png)

## 三、处理数据

### 3.1 简单变量

#### 3.1.1 bit与byte

bit（位、比特）：
* 计算机内存的基本单元；
* 8位的内存块可以设置出256中不同的组合，因此每一位都可以有两种设置；
  * 8位的总组合数为：`2 * 2 * 2 * 2 * 2 * 2 * 2 * 2`，即256；
  * 因此8位单元可以表示`0-255`（符号类型）或者`-128到127`（无符号类型）；
  * 同理16位单元可以表示`0-65535`（符号类型）或者`-32768到32767`（无符号类型）；

byte（字节）：
* 字节（byte）通常指的是8位的内存单元；
  * 从这个意义讲，字节指的就是描述计算机内存量的度量单位；
  * 1KB = 1024Byte；
  * 1MB = 1024KB；
  * 1GB = 1024MB；
  * 1TB = 1024GB；
> C++对字节的定义与此不同，C++字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说，可能取值的数目必须等于或超过字符数目。

width（宽度）：
* 用于描述存储整数时使用的内存量；
  * 使用的内存越多，则越宽；
  * C++的基本整型（按宽度递增的顺序排序）分别是char（最常用来表示字节，而不是数字）、short、int、long、long long（C++11新增）；
  * 每种基本整型都有符号版本和无符号版本；

#### 3.1.2 整型变量

* short
    * 4 byte
* int
  * 4 byte
* long
  * 4 byte
* long long
  * 8 byte

头文件climits定义了符号常量来表示类型的限制，下图为对该文件中定义的符号常量进行了总结：
![symbolic_constants_01.png](..%2Fimage%2Fsymbolic_constants_01.png)
![symbolic_constants_02.png](..%2Fimage%2Fsymbolic_constants_02.png)

#### 3.1.3 无符号类型

前面提到的4种整型都有一种不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值；  
例如，如果short表示的范围为-32768到+32767，则无符号版本的表示范围为0-65535；  
使用关键字`unsigned`来修改声明，例如：`unsigned short change`；

整型溢出:

> 观看../../code/integerOverflow.cpp代码；
* 当有符号整型处于最大值时，再进行+1操作时，值会变为范围的下限；
  * 如short类型的值会从32767变为-32768；
* 当有符号整型处于最小值时，在进行-1操作时，值会变为范围的上限；
  * 如short类型的值会从-32768变为32767；
* 当无符号整型处于最大值时，再进行+1操作时，值会变为范围的下限；
  * 如unsigned short类型的值会从65535变为0；
* 当无符号整型处于最小值时，再进行-1操作时，值会变为范围的上限；
  * 如unsigned short类型的值会从0变为65535；

![integerOverflow.png](..%2Fimage%2FintegerOverflow.png)

#### 3.1.4 整型类型选择

选择整型类型时，还要考虑到进行移植的时候会不会出现溢出的情况：
  * 如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long；
  * 即使系统上int为32位，也应这样做，这样将程序移植到16位系统时，就不会突然无法正常工作；
  * 如果要存储的值超过20亿，可使用long long；

同时，还要考虑低位系统移植到高位系统时，占用内存量会加倍：
  * 如假设要将程序从int为16位的系统移植到32位的系统，则用于存储int数组的内存量则加倍；
  * 但short数组不受影响；

#### 3.1.5 整型字面值

十进制：
  * 第一位`1~9`；

八进制：
  * 第一位为`0`，第二位为`1~7`；

十六进制：
  * 如果前两位为`0x`或`0X`；
  * 字符a~f和A~F表示了十六进制位，对应10~15，如0xF为15，,0xA5为165（10个16加5个1）；

如果要以十六进制或八进制方式显示值，则可以使用cout的一些特殊特性：
  * 前面指出过，头文件iostream提供了控制符endl，用于指示cout重起一行；
  * 同样，它还提供了控制符dec（decimal，十进制）、hex（hexadecimal，十六进制）、oct（octal， 八进制），分别指示cout以十进制、十六进制、八进制格式显示整数；
    * 例如，使用`cout << hex;`来修改整数的方式；
    * 因为标识符位于名称空间std中，而程序使用了该名称空间，因此不能将hex用作变量名；
    * 然而，如果省略编译指令using，而使用std::cout、std::endl、std::hex和std::oct，则可以将hex用作变量名；

> 示例代码请看hex_pct.cpp


## 三、指针和自由存储空间

### 3.1 声明和初始化指针

面向对象编程与传统的过程性编程的区别在于：
  * OOP强调的是在运行阶段（而不是编译阶段）进行决策；
    * C++采用的方法是：使用关键字`new`请求正确数量的内存以及使用指针来跟踪新分配的内存的位置;
    * 处理存储数据的新策略刚好相反：将地址视为指定的量，而将值视为派生量；
    * 一种特殊的变量：`指针`用于存储值的地址；
      * 指针名表示的是地址；
      * `*`运算符被称为间接值（indirect value）或接触引用（dereferencing）运算符；
      * `&`地址运算符，获取变量在内存中的地址；


可以在声明语句中初始化指针：被初始化的是指针，而不是它指向的值：
```
int higgens = 5;
int* pt = &higgens;  // 将pt（而不是*pt）的值设置为&higgens，pt表示指向int类型的指针变量
```

### 3.2 指针的危险

> 重点！！！ ：一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。

在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存；  
为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦，如下示例：
```
/* 
没有给指针fellow分配地址，即没有被初始化，他可能有任何值；
不管值是什么，程序都将它解释为存储223323的地址（即使地址恰巧是程序代码的地址）；
并且fellow所指向的地方很可能并不是所要存储223323的地方；
 */
 
long* fellow;       // create a pointer-to-long
*fellow = 223323;   // place a value in never-never land
```

### 3.3 使用new来分配内存

> `new`与`delete`字段配合使用，new分配地址，delete释放new分配的地址；

程序员告诉new，需要为哪种数据类型分配内存；  
new将找到一个长度正确的内存块，并返回该内存块的地址；  
```
/*
new int告诉程序，需要适合存储int的内存，new运算符根据类型来确定需要多少字节的内存；
然后，它找到这样的内存，并返回其地址；
接下来，将地址赋给pn，pn是被声明为指向int的指针；
现在，pn是地址，*pn是存储在那里的值；
 */
 
int* pn = new int;    // allocate memory with new
....                  // use the memory
delete pn;            //free memory with delete when done
delete pn;            // not ok, can`t delete memory again

int jugs = 6;
int* pi = &jugs;
delete pi             // not ok, delete just can use for `new`, but this memory not allocated by new
```

> delete释放内存，但不会删除指针本身；

### 3.4 使用new来创建动态数组

如果通过声明来创建数组，则在程序被编译时将为它分配内存空间，不管程序最终是否使用数组，数组都在那里，它占用了内存；  
在编译时给数组分配内存被称为`静态联编（static binding）`，意味着数组是在编译时加入到程序中的；

使用new时，如果在运行阶段需要数组，则创建它，如果不需要，则不创建；  
还可以再程序运行时选择数组的长度；  
这被称为`动态联编（dynamic binding）`，意味着数组是在程序运行时创建的，这种数组叫做`动态数组（dynamic array）`；

使用静态联编时，必须在编写程序时指定数组的长度；  
使用动态联编时，程序将在运行时确定数组的长度；

```
/*
new 运算符返回第一个元素的地址，并赋给指针，即指针指向动态数组在内存中的第一个元素的地址；
释放地址时，使用方括号，告诉程序应该释放整个数组，而不仅仅是指针指向的元素；
 */
 
int* psome = new int [10];   // get a block of 10 ints
....
delete [] psome;             // free a dynamic array
```

使用new和delete时，应该遵循以下规则：
  * 不要使用delete来释放不是new分配的内存；
  * 不要使用delete来释放同一内存块两次；
  * 如果使用new []为数组分配内存，则应使用delete []来释放；
  * 如果使用new []为一个实体分配内存，则应使用delete（没有方括号）来释放；
  * 对空指针应用delete是安全的；

> 不能使用sizeof运算符来确定动态分配的数组包含的字节数；

使用动态数组，只要把指针当作数组名使用即可，以上面的psome为例：
  * 对于第一个元素，可以使用psome[0]操作，第二个使用psome[1]操作，后面的8个数以此类推；
  * 当使用`psome += 1`，指针向后移动一位，现在的psome[0]是原来的第二个数字，即现在动态数组只剩9个数字；
  * 当使用`psome -= 1`，指针向前移动一位，现在的psome[0]是原来的第一个数字，即现在动态数组又为10个数字；








































    